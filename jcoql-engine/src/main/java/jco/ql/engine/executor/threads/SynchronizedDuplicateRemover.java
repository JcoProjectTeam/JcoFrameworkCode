package jco.ql.engine.executor.threads;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;

import jco.ql.byZun.ZunTimer;
import jco.ql.byZun.ZunWarningTracker;
import jco.ql.engine.exception.ExecuteProcessException;
import jco.ql.model.DocumentDefinition;


/**
	PF - Class created to handle parallel duplicate documents remove generated by Join
	Si puo' usare anche per il JOIN e il FILTER!
*/
public class SynchronizedDuplicateRemover extends Thread implements Runnable {
    private LinkedBlockingQueue<DocumentDefinition> queue;
	private int prime1L, prime2L, halfPrime1L, halfPrime2L;
	private DALPrimeLevel[] collisions;
	private List<DocumentDefinition> outDocs;
	private boolean removeDuplicates;
	private volatile boolean isRunning;
	private String sdrInfo;
	
	private boolean zunInformer;
	private long zunStep;
	private long zunTotDoc;
	private long zunNSteps;
	private long zunMaxSteps;
	
	private class DocumentArrayList {
		List<DocumentDefinition> dal;
		DocumentArrayList () {
			dal = new ArrayList<DocumentDefinition>();
		}
	}

	/* Document Array List Prime Level */
	private class DALPrimeLevel {
		DocumentArrayList[] dpl;
		DALPrimeLevel (int dim) {
			dpl = new DocumentArrayList[dim];
			for (int i=0; i<dim; i++)
				dpl[i] = null;
		}

	}

	public void setInfomer (long nDoc, long steps) {
		zunInformer = true;
		zunStep = nDoc/steps;
		zunMaxSteps = steps;
	}
    public SynchronizedDuplicateRemover(LinkedBlockingQueue<DocumentDefinition> queue, boolean remove) {
        this.queue = queue;
        isRunning = true;
		prime1L = 1;
		halfPrime1L = 1;
		prime2L = 1;
		halfPrime2L = 1;
		collisions = null;
		outDocs = new ArrayList<DocumentDefinition>();
		this.removeDuplicates = remove;
		sdrInfo = "[SynchronizedDuplicateRemover " + this.getId() + "]";

		setPriority(10);
		zunInformer = false;
		zunStep = 0;
		zunTotDoc=0;
		zunNSteps = 0;
		zunMaxSteps = 0;
	}

    
    
    public int getPrime1L () {
    	return prime1L;
    }
    public int getPrime2L () {
    	return prime2L;
    }
    public int getPrimes () {
    	return prime1L*prime2L;
    }
    public void setDimensions (int dim) {
		dim = (int) Math.sqrt(dim+1);
		setDimensions (dim, dim);
    }
    public void setDimensions (int dim1, int dim2) {
		int dim = 0;
		if (removeDuplicates) {
			dim = (int)Math.sqrt(dim1 * dim2 * 3.0 / 2.0 + 1);
			prime1L = Primer.getNextIterativelyFast(dim);
			halfPrime1L = (prime1L-1)/2;
			prime2L = Primer.getNextIterativelyFast(prime1L+1);
			halfPrime2L = (prime2L-1)/2;
			collisions = new DALPrimeLevel[prime1L];
			for (int i=0; i<prime1L; i++)
				collisions[i] = null;
		}
	}


    
    @Override
    public void run() {
        try {
        	while (isRunning) {
                DocumentDefinition doc = queue.take();
                consumeDoc(doc);
 //               zunReportProgress(true);
        	} 
        }
        catch (InterruptedException ie) {
        	isRunning = false;
        	ZunWarningTracker.getInstance().addWarning(sdrInfo + ": Forced Interruption -\t" +  queue.size());
        }    
        terminate ();
     }


    
     private void consumeDoc(DocumentDefinition dd) {
// ZUN - qui viene generato un errore dd nullo!    	
		String st = dd.toString();
		int hash = st.hashCode();
		int collisionNdx = (hash % (halfPrime1L+1)) + halfPrime1L;
		int collisionNdx2l = (hash % (halfPrime2L+1)) + halfPrime2L;

		if (!removeDuplicates)
			outDocs.add(dd);
		else {
			if (collisions[collisionNdx] == null) {
				outDocs.add(dd);

				DocumentArrayList dl = new DocumentArrayList();
				dl.dal = new ArrayList<DocumentDefinition>();
				dl.dal.add(dd);

				DALPrimeLevel dpl = new DALPrimeLevel(prime2L);
				dpl.dpl[collisionNdx2l] = dl;
				collisions[collisionNdx] = dpl;
			}
			else {
				DALPrimeLevel dpl = collisions[collisionNdx];
				if (dpl.dpl[collisionNdx2l] == null) {
					outDocs.add(dd);

					DocumentArrayList dl = new DocumentArrayList();
					dl.dal = new ArrayList<DocumentDefinition>();
					dl.dal.add(dd);
					dpl.dpl[collisionNdx2l] = dl;
				}
				else {
					boolean b = false;
					String st2 = null;
					for(DocumentDefinition dd2 : dpl.dpl[collisionNdx2l].dal) {
						st2 = dd2.toString();
						b = b || st.equals(st2);
					}
					if (!b) { // collision... put doc in queue
						outDocs.add(dd);
						dpl.dpl[collisionNdx2l].dal.add(dd);
					}
				}
			}
		}
	}

     

     void zunReportProgress (boolean showReport){
  		zunTotDoc++;
  		
  		if (zunInformer && (zunStep!=0) && (zunTotDoc%zunStep==0)) {
  			zunNSteps++;
  			if (showReport) {
	  			ZunWarningTracker.add(sdrInfo + ". Progress:\t" + zunNSteps + " / " + zunMaxSteps);
	  			ZunTimer.getInstance().getPartial("SRD. Step-" + zunNSteps + " / " + zunMaxSteps);
  			} else {
	  			ZunWarningTracker.add(sdrInfo + ". T*-Progress:\t" + zunNSteps + " / " + zunMaxSteps);
	  			ZunTimer.getInstance().getPartial("SRD. T*-Step-" + zunNSteps + " / " + zunMaxSteps);
  			}
//  			ZunWarningTracker.getInstance().saveToFile("TRACKER PARTIAL");
//  			ZunTimer.getInstance().saveToFile("TIMER PARTIAL");
  		}
     }

     
     void terminate () {
     	while (!queue.isEmpty()) {
//     		zunReportProgress(false);
             DocumentDefinition doc;
 			try {
 				doc = queue.take();
 	            consumeDoc(doc);
 	         } catch (InterruptedException e) {
             	ZunWarningTracker.getInstance().addWarning(sdrInfo + ": unexpected termination");
             	throw new ExecuteProcessException(sdrInfo + ": unexpected termination");
 			}
     	}
     }


   public List<DocumentDefinition> getDocs () {    	
    	return outDocs;
    }
}

